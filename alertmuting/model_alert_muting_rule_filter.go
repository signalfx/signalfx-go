/*
 * Incidents and Alerts API
 *
 *  ## Incidents  An incident is the combination of the alert event and clear event for a detector rule.  Detectors monitor metric time series; in the context of a detector, these are known as a **signal**. When a condition defined in a  **detector rule** matches the signal, the detector does the following:    * Triggers an **alert** that you can view in a number of places throughout SignalFx   * Generates an **event** that you can view in the web UI. SignalFx also stores the     event.   * Sends one or more **notifications**, so that users learn about the alert     even if they're not looking at the web UI.  When the signal no longer matches the condition in the detector rule, the detector generates a **clear event** and sends out a second notification. Together, the alert and clear event for a detector rule constitute an  incident.  ## Alert muting rules  Alert muting rules (known as muting rules in the web UI) stop a detector from sending notifications, based on properties you specify in the rule. When you mute a notification, the detector still triggers alerts and  generates events, and you can see these in their respective locations in the web UI. However, the detector doesn't send notifications to recipients who would normally receive them.  Use alert muting rules to mute certain notifications when you want to schedule server downtime or test new code or configurations. You can set alert muting rules to last for a specific time period or to last indefinitely.  In some cases, SignalFx may send notifications during an alert muting period. To learn more, see the section  [Considerations for alert muting](https://developers.signalfx.com/detectors_events_alerts/detectors_overview.html#_considerations_for_alert_muting) in the API concepts guide.  <div  style=\"   position: relative;    padding: 0.75rem 1.25rem;    margin-bottom: 1rem;    border: 1px solid transparent;    border-radius: 0.25rem;    color: #0c5460;    background-color: #d1ecf1;    border-color: #bee5eb; \"> <strong>NOTE:</strong> Although the Detectors API only works with detectors you create in the API (<strong>v2</strong> detectors, the <code>/incident</code> and <code>/alertmuting</code> endpoints work with <em>all</em> events and incidents, regardless of which detector version created them. This means that you can use the endpoints to work with incidents and alert muting rules for detectors you create in the web UI. </div>
 *
 * API version: 3.2.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package alertmuting

import (
	"encoding/json"
	"errors"
	"strings"
)

// Properties of an alert muting rule, in the form of a JSON object. **NOTE:** You can't create or update properties marked read-only. You receive read-only properties in response bodies for the following:    * **GET** `/alertmuting`   * **POST** `/alertmuting`   * **GET** `/alertmuting/{id}`   * **PUT** `/alertmuting/{id}`
type AlertMutingRuleFilter struct {
	NOT           bool          `json:"NOT,omitempty"`
	Property      string        `json:"property,omitempty"`
	PropertyValue StringOrArray `json:"propertyValue,omitempty"`
}

type StringOrArray struct {
	Values []string
}

func (soa *StringOrArray) MarshalJSON() ([]byte, error) {
	if len(soa.Values) == 1 {
		return json.Marshal(soa.Values[0])
	} else if len(soa.Values) > 1 {
		return json.Marshal(soa.Values)
	}
	return nil, errors.New("propertyValue has to be a string or array of strings")
}

func (soa *StringOrArray) UnmarshalJSON(b []byte) error {
	if len(b) == 0 {
		return nil // empty
	}
	// See if we can guess based on the first character
	trimmed := strings.TrimSpace(string(b))
	switch trimmed[0] {
	case '"':
		return soa.unmarshalSingle(b)
	case '[':
		return soa.unmarshalMany(b)
	}
	return nil
}

func (soa *StringOrArray) unmarshalSingle(b []byte) error {
	var s string
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	soa.Values = []string{s}
	return nil
}

func (soa *StringOrArray) unmarshalMany(b []byte) error {
	var s []string
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	soa.Values = s
	return nil
}
